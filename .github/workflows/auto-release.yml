name: Auto Release
run-name: Auto-increment version and deploy üöÄ

permissions:
  contents: write
  actions: read
  pull-requests: write

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
  push:
    branches:
      - main
    paths:
      - 'src/**'
      - 'package.json'
      - 'README.md'
      - 'CHANGELOG.md'

jobs:
  auto-release:
    runs-on: ubuntu-latest
    # Skip if the last commit was made by github-actions[bot] to prevent infinite loops
    if: >
      github.event_name == 'workflow_dispatch' || 
      (github.event_name == 'push' && 
       !contains(github.event.head_commit.message, 'chore: bump version') && 
       github.event.head_commit.author.name != 'github-actions[bot]')
    steps:
      - name: Debug workflow trigger
        run: |
          echo "üîç Workflow triggered by: ${{ github.event_name }}"
          echo "üìù Commit message: ${{ github.event.head_commit.message }}"
          echo "üë§ Commit author: ${{ github.event.head_commit.author.name }}"
          echo "üåü Commit SHA: ${{ github.sha }}"
          
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # Use PAT_TOKEN if available, otherwise use GITHUB_TOKEN
          token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          persist-credentials: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          registry-url: "https://registry.npmjs.com"

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: latest

      - name: Install dependencies
        run: |
          if [ -f "pnpm-lock.yaml" ]; then
            echo "üì¶ Installing with frozen lockfile..."
            pnpm install --frozen-lockfile
          else
            echo "üì¶ No lockfile found, installing without frozen lockfile..."
            pnpm install --no-frozen-lockfile
          fi

      - name: Build and test
        run: |
          pnpm build
          pnpm test || echo "No tests configured, skipping..."

      - name: Get current version from npm registry
        id: get_current_version
        run: |
          # Try to get the current version from npm registry
          CURRENT_VERSION=$(curl -s "https://registry.npmjs.org/@rnwonder/adonis-autoswagger/latest" | jq -r '.version' 2>/dev/null || echo "0.0.0")
          
          # If the package doesn't exist on npm yet, use the package.json version
          if [ "$CURRENT_VERSION" = "null" ] || [ "$CURRENT_VERSION" = "0.0.0" ]; then
            CURRENT_VERSION=$(node -p "require('./package.json').version")
            echo "üì¶ Package not found on npm, using package.json version: $CURRENT_VERSION"
          else
            echo "üì¶ Current npm version: $CURRENT_VERSION"
          fi
          
          echo "CURRENT_VERSION=$CURRENT_VERSION" >> $GITHUB_OUTPUT

      - name: Determine release type
        id: release_type
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          else
            # Auto-determine release type based on commit messages
            COMMITS=$(git log --pretty=format:"%s" $(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")..HEAD)
            
            if echo "$COMMITS" | grep -q "BREAKING CHANGE\|major:"; then
              RELEASE_TYPE="major"
            elif echo "$COMMITS" | grep -q "feat:\|feature:\|minor:"; then
              RELEASE_TYPE="minor"
            else
              RELEASE_TYPE="patch"
            fi
          fi
          
          echo "üéØ Release type: $RELEASE_TYPE"
          echo "RELEASE_TYPE=$RELEASE_TYPE" >> $GITHUB_OUTPUT

      - name: Calculate new version
        id: new_version
        run: |
          CURRENT_VERSION="${{ steps.get_current_version.outputs.CURRENT_VERSION }}"
          RELEASE_TYPE="${{ steps.release_type.outputs.RELEASE_TYPE }}"
          
          # Split version into parts
          IFS='.' read -r -a VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}
          
          # Increment based on release type
          case $RELEASE_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "üÜï New version: $NEW_VERSION"
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Check if version already exists
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.NEW_VERSION }}"
          
          # Check if version exists on npm (this is the important check)
          NPM_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://registry.npmjs.org/@rnwonder/adonis-autoswagger/$NEW_VERSION")
          if [ "$NPM_STATUS" = "200" ]; then
            echo "‚ùå Version $NEW_VERSION already exists on npm"
            exit 1
          fi
          
          # Check if tag exists locally/remotely
          TAG_EXISTS_LOCAL=$(git tag -l | grep -c "^v$NEW_VERSION$" || true)
          TAG_EXISTS_REMOTE=$(git ls-remote --tags origin | grep -c "refs/tags/v$NEW_VERSION$" || true)
          
          if [ "$TAG_EXISTS_LOCAL" -gt 0 ] || [ "$TAG_EXISTS_REMOTE" -gt 0 ]; then
            echo "‚ö†Ô∏è Git tag v$NEW_VERSION already exists, but version not published to npm"
            echo "This usually means a previous workflow failed during publishing"
            echo "Continuing with npm publish only..."
            echo "SKIP_GIT_OPERATIONS=true" >> $GITHUB_ENV
          else
            echo "‚úÖ Version $NEW_VERSION is available for both git and npm"
            echo "SKIP_GIT_OPERATIONS=false" >> $GITHUB_ENV
          fi

      - name: Update package.json version
        run: |
          if [ "$SKIP_GIT_OPERATIONS" = "true" ]; then
            echo "‚è≠Ô∏è Skipping package.json update (git operations skipped)"
            exit 0
          fi
          
          NEW_VERSION="${{ steps.new_version.outputs.NEW_VERSION }}"
          # Update package.json with new version
          node -e "
            const pkg = require('./package.json');
            pkg.version = '$NEW_VERSION';
            require('fs').writeFileSync('./package.json', JSON.stringify(pkg, null, 2) + '\n');
          "
          echo "‚úÖ Updated package.json to version $NEW_VERSION"

      - name: Update changelog
        run: |
          if [ "$SKIP_GIT_OPERATIONS" = "true" ]; then
            echo "‚è≠Ô∏è Skipping changelog update (git operations skipped)"
            exit 0
          fi
          
          NEW_VERSION="${{ steps.new_version.outputs.NEW_VERSION }}"
          RELEASE_TYPE="${{ steps.release_type.outputs.RELEASE_TYPE }}"
          
          # Create new changelog entry
          cat > temp_changelog.md << EOF
          # Changelog
          
          ## [$NEW_VERSION] - $(date +%Y-%m-%d)
          
          ### $(echo $RELEASE_TYPE | sed 's/.*/\u&/')
          - Auto-generated $RELEASE_TYPE release
          - Version increment: ${{ steps.get_current_version.outputs.CURRENT_VERSION }} ‚Üí $NEW_VERSION
          
          EOF
          
          # Append existing changelog (skip the first line)
          if [ -f CHANGELOG.md ]; then
            tail -n +2 CHANGELOG.md >> temp_changelog.md
          fi
          
          mv temp_changelog.md CHANGELOG.md
          echo "‚úÖ Updated CHANGELOG.md"

      - name: Build final package
        run: pnpm build

      - name: Commit version changes
        run: |
          if [ "$SKIP_GIT_OPERATIONS" = "true" ]; then
            echo "‚è≠Ô∏è Skipping version commit (git operations skipped)"
            exit 0
          fi
          
          NEW_VERSION="${{ steps.new_version.outputs.NEW_VERSION }}"
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add package.json CHANGELOG.md
          git commit -m "chore: bump version to v$NEW_VERSION"
          
          echo "‚úÖ Committed version changes"

      - name: Create and push tag
        run: |
          if [ "$SKIP_GIT_OPERATIONS" = "true" ]; then
            echo "‚è≠Ô∏è Skipping git tag creation (tag already exists)"
            exit 0
          fi
          
          NEW_VERSION="${{ steps.new_version.outputs.NEW_VERSION }}"
          
          # Create tag locally first
          git tag "v$NEW_VERSION"
          
          # Try to push to main branch and tag
          if git push origin main && git push origin "v$NEW_VERSION"; then
            echo "‚úÖ Successfully pushed to main and created tag v$NEW_VERSION"
          else
            echo "‚ùå Failed to push to repository"
            echo ""
            echo "This is likely a permissions issue. To fix this:"
            echo "1. Go to Repository Settings ‚Üí Actions ‚Üí General"
            echo "2. Set 'Workflow permissions' to 'Read and write permissions'"
            echo "3. Enable 'Allow GitHub Actions to create and approve pull requests'"
            echo ""
            echo "If you have branch protection rules, you may need to:"
            echo "1. Create a Personal Access Token with 'repo' scope"
            echo "2. Add it as repository secret 'PAT_TOKEN'"
            echo ""
            echo "For more details, see: https://docs.github.com/en/actions/security-guides/automatic-token-authentication"
            exit 1
          fi

      - name: Generate release changelog
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.NEW_VERSION }}"
          CURRENT_VERSION="${{ steps.get_current_version.outputs.CURRENT_VERSION }}"
          
          echo "# Release v$NEW_VERSION" > RELEASE_CHANGELOG.md
          echo "" >> RELEASE_CHANGELOG.md
          echo "**Full Changelog**: v$CURRENT_VERSION...v$NEW_VERSION" >> RELEASE_CHANGELOG.md
          echo "" >> RELEASE_CHANGELOG.md
          
          # Get commits since last version
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
          if [[ -n "$PREV_TAG" ]]; then
            echo "## Changes since $PREV_TAG" >> RELEASE_CHANGELOG.md
            echo "" >> RELEASE_CHANGELOG.md
            git log --pretty=format:"- %s (%h)" $PREV_TAG..HEAD >> RELEASE_CHANGELOG.md
          else
            echo "## Changes in this release" >> RELEASE_CHANGELOG.md
            echo "" >> RELEASE_CHANGELOG.md
            git log --pretty=format:"- %s (%h)" --max-count=10 >> RELEASE_CHANGELOG.md
          fi
          
          echo "" >> RELEASE_CHANGELOG.md
          echo "" >> RELEASE_CHANGELOG.md
          echo "---" >> RELEASE_CHANGELOG.md
          echo "_Released on $(date)_" >> RELEASE_CHANGELOG.md

      - name: Create GitHub Release
        run: |
          if [ "$SKIP_GIT_OPERATIONS" = "true" ]; then
            echo "‚è≠Ô∏è Skipping GitHub release creation (tag already exists, release may already exist)"
            # Check if release already exists
            RELEASE_EXISTS=$(curl -s -o /dev/null -w "%{http_code}" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/releases/tags/v${{ steps.new_version.outputs.NEW_VERSION }}")
            
            if [ "$RELEASE_EXISTS" = "200" ]; then
              echo "‚úÖ GitHub release already exists for v${{ steps.new_version.outputs.NEW_VERSION }}"
            else
              echo "‚ÑπÔ∏è GitHub release does not exist yet, will be created by the action below"
            fi
          fi
        
      - name: Create GitHub Release (if needed)
        if: env.SKIP_GIT_OPERATIONS != 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: "v${{ steps.new_version.outputs.NEW_VERSION }}"
          name: "Release v${{ steps.new_version.outputs.NEW_VERSION }}"
          body_path: RELEASE_CHANGELOG.md
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish to npm
        run: pnpm publish --no-git-checks
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Success notification
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.NEW_VERSION }}"
          echo "üéâ Successfully released v$NEW_VERSION!"
          echo "üì¶ Published: @rnwonder/adonis-autoswagger@$NEW_VERSION"
          echo "üîó GitHub Release: https://github.com/rnwonder/adonisjs-autoswagger/releases/tag/v$NEW_VERSION"
          echo "üìã npm: https://www.npmjs.com/package/@rnwonder/adonis-autoswagger/v/$NEW_VERSION"
